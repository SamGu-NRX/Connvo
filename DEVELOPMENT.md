# LinkedUp Development Guide

This guide covers local development setup, coding patterns, and best practices for the LinkedUp Convex backend.

## Quick Start

```bash
# 1. Clone and setup
git clone <repository-url>
cd linkedup
./scripts/setup-dev.sh

# 2. Start development
npm run convex:dev    # Terminal 1
npm run dev          # Terminal 2
```

## Project Structure

```
├── convex/                 # Convex backend
│   ├── schema.ts          # Database schema
│   ├── auth.config.ts     # WorkOS auth config
│   ├── auth/              # Authentication & authorization
│   ├── users/             # User management
│   ├── meetings/          # Meeting lifecycle
│   ├── notes/             # Collaborative notes
│   ├── transcripts/       # Live transcription
│   ├── lib/               # Shared utilities
│   └── environments/      # Environment configs
├── src/                   # Next.js frontend
├── scripts/               # Deployment scripts
└── .github/workflows/     # CI/CD pipelines
```

## Development Workflow

### 1. Environment Setup

**Required Environment Variables:**

```env
# WorkOS Authentication
WORKOS_CLIENT_ID=client_your_id
WORKOS_API_KEY=sk_test_your_key
WORKOS_COOKIE_PASSWORD=32_char_minimum_password
NEXT_PUBLIC_WORKOS_REDIRECT_URI=http://localhost:3000/callback

# Convex (auto-generated by CLI)
CONVEX_DEPLOY_KEY=your_deploy_key
NEXT_PUBLIC_CONVEX_URL=https://your-url.convex.cloud

# Optional: AI & External Services
OPENAI_API_KEY=your_openai_key
NEXT_PUBLIC_STREAM_API_KEY=your_stream_key
STREAM_SECRET_KEY=your_stream_secret
```

### 2. Code Generation

Convex automatically generates TypeScript types:

```bash
# Generate types (runs automatically with convex dev)
npm run convex:codegen

# Manual generation if needed
npx convex codegen
```

### 3. Database Schema Changes

1. **Update Schema** (`convex/schema.ts`)

   ```typescript
   // Add new table
   newTable: defineTable({
     field1: v.string(),
     field2: v.number(),
   }).index("by_field1", ["field1"]),
   ```

2. **Generate Types**

   ```bash
   npm run convex:codegen
   ```

3. **Update Functions**
   ```typescript
   // Use new types automatically available
   export const createItem = mutation({
     args: { field1: v.string(), field2: v.number() },
     returns: v.id("newTable"),
     handler: async (ctx, args) => {
       return await ctx.db.insert("newTable", args);
   ,
   });
   ```

## Coding Patterns

### 1. Function Definition

**Always use the new function syntax:**

```typescript
import { query, mutation, action } from "./_generated/server";
import { v } from "convex/values";

// Query (read-only)
export const getUser = query({
  args: { userId: v.id("users") },
  returns: v.union(v.object({...}), v.null()),
  handler: async (ctx, args) => {
    return await ctx.db.get(args.userId);
  },
});

// Mutation (read/write)
export const updateUser = mutation({
  args: {
    userId: v.id("users"),
    name: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    await ctx.db.patch(args.userId, { name: args.name });
    return null;
  },
});

// Action (external APIs)
export const sendEmail = action({
  args: { to: v.string(), subject: v.string() },
  returns: v.null(),
  handler: async (ctx, args) => {
    // Call external service
    await emailService.send(args);
    return null;
  },
});
```

### 2. Authentication & Authorization

**Always validate authentication:**

```typescript
import { requireIdentity, assertMeetingAccess } from "../auth/guards";

export const getMeeting = query({
  args: { meetingId: v.id("meetings") },
  returns: v.union(v.object({...}), v.null()),
  handler: async (ctx, args) => {
    // Validate access to specific meeting
    await assertMeetingAccess(ctx, args.meetingId);
    return await ctx.db.get(args.meetingId);
  },
});

export const updateProfile = mutation({
  args: { name: v.string() },
  returns: v.null(),
  handler: async (ctx, args) => {
    // Get authenticated user
    const { userId } = requireIdentity(ctx);

    const user = await ctx.db
      .query("users")
      .withIndex("by_workos_id", q => q.eq("workosUserId", userId))
      .unique();

    if (user) {
      await ctx.db.patch(user._id, { displayName: args.name });
    }
    return null;
  },
});
```

### 3. Database Queries

**Use indexes for performance:**

```typescript
// ✅ Good: Uses index
const user = await ctx.db
  .query("users")
  .withIndex("by_email", (q) => q.eq("email", email))
  .unique();

// ✅ Good: Bounded query
const recentMeetings = await ctx.db
  .query("meetings")
  .withIndex("by_created", (q) => q.eq("userId", userId))
  .order("desc")
  .take(10);

// ❌ Bad: No index, unbounded
const allUsers = await ctx.db.query("users").collect();
```

### 4. Error Handling

**Use consistent error patterns:**

```typescript
export const deleteMeeting = mutation({
  args: { meetingId: v.id("meetings") },
  returns: v.null(),
  handler: async (ctx, args) => {
    // Validate access
    const mp = await assertMeetingAccess(ctx, args.meetingId, "host");

    // Check meeting state
    const meeting = await ctx.db.get(args.meetingId);
    if (!meeting) {
      throw new Error("Meeting not found");
    }

    if (meeting.state === "active") {
      throw new Error("Cannot delete active meeting");
    }

    // Perform deletion
    await ctx.db.delete(args.meetingId);
    return null;
  },
});
```

### 5. Real-time Subscriptions

**Design for reactivity:**

```typescript
// Client automatically updates when data changes
export const subscribeMeetingState = query({
  args: { meetingId: v.id("meetings") },
  returns: v.union(v.object({...}), v.null()),
  handler: async (ctx, args) => {
    await assertMeetingAccess(ctx, args.meetingId);

    return await ctx.db
      .query("meetingState")
      .withIndex("by_meeting", q => q.eq("meetingId", args.meetingId))
      .unique();
  },
});
```

## Testing

### 1. Function Testing

```typescript
// convex/users/mutations.test.ts
import { convexTest } from "convex-test";
import { test, expect } from "vitest";
import { api } from "./_generated/api";

test("createUser creates user correctly", async () => {
  const t = convexTest();

  const userId = await t.mutation(api.users.mutations.createUser, {
    email: "test@example.com",
    name: "Test User",
  });

  expect(userId).toBeDefined();

  const user = await t.query(api.users.queries.getUser, { userId });
  expect(user?.email).toBe("test@example.com");
});
```

### 2. Authentication Testing

```typescript
test("requires authentication", async () => {
  const t = convexTest();

  // Should throw without auth
  await expect(t.query(api.users.queries.getCurrentUser, {})).rejects.toThrow(
    "Authentication required",
  );
});
```

### 3. Integration Testing

```typescript
test("meeting lifecycle", async () => {
  const t = convexTest();

  // Create user
  const userId = await t.mutation(api.users.mutations.createUser, {
    email: "host@example.com",
    name: "Host User",
  });

  // Create meeting
  const meetingId = await t.mutation(api.meetings.lifecycle.createMeeting, {
    title: "Test Meeting",
  });

  // Start meeting
  await t.mutation(api.meetings.lifecycle.startMeeting, { meetingId });

  // Verify state
  const meeting = await t.query(api.meetings.queries.getMeeting, { meetingId });
  expect(meeting?.state).toBe("active");
});
```

## Performance Guidelines

### 1. Query Optimization

```typescript
// ✅ Good: Specific, indexed query
const userMeetings = await ctx.db
  .query("meetingParticipants")
  .withIndex("by_user", (q) => q.eq("userId", userId))
  .take(20);

// ❌ Bad: Unindexed filter
const userMeetings = await ctx.db
  .query("meetingParticipants")
  .filter((q) => q.eq(q.field("userId"), userId))
  .take(20);
```

### 2. Batching Operations

```typescript
// ✅ Good: Batch related operations
export const createMeetingWithParticipants = mutation({
  args: {
    title: v.string(),
    participantIds: v.array(v.id("users")),
  },
  returns: v.id("meetings"),
  handler: async (ctx, args) => {
    const meetingId = await ctx.db.insert("meetings", {
      title: args.title,
      // ... other fields
    });

    // Batch participant creation
    for (const userId of args.participantIds) {
      await ctx.db.insert("meetingParticipants", {
        meetingId,
        userId,
        role: "participant" as const,
        presence: "invited" as const,
        createdAt: Date.now(),
      });
    }

    return meetingId;
  },
});
```

### 3. Pagination

```typescript
export const getMeetings = query({
  args: {
    paginationOpts: paginationOptsValidator,
  },
  returns: v.object({
    page: v.array(v.object({...})),
    isDone: v.boolean(),
    continueCursor: v.union(v.string(), v.null()),
  }),
  handler: async (ctx, args) => {
    const { userId } = requireIdentity(ctx);

    return await ctx.db
      .query("meetings")
      .withIndex("by_organizer", q => q.eq("organizerId", userId))
      .order("desc")
      .paginate(args.paginationOpts);
  },
});
```

## Debugging

### 1. Function Logs

```typescript
export const debugFunction = mutation({
  args: { data: v.any() },
  returns: v.null(),
  handler: async (ctx, args) => {
    console.log("Debug data:", args.data);

    try {
      // Your logic here
    } catch (error) {
      console.error("Error occurred:", error);
      throw error;
    }

    return null;
  },
});
```

### 2. Convex Dashboard

- **URL**: https://dashboard.convex.dev
- **Features**:
  - Real-time function logs
  - Performance metrics
  - Database browser
  - Function execution history

### 3. Local Development

```bash
# View logs in terminal
npm run convex:dev

# Run specific function
npx convex run users/queries:getCurrentUser

# Check database
npx convex dashboard
```

## Common Patterns

### 1. Upsert Pattern

```typescript
export const upsertUser = mutation({
  args: {
    workosUserId: v.string(),
    email: v.string(),
    name: v.optional(v.string()),
  },
  returns: v.id("users"),
  handler: async (ctx, args) => {
    const existing = await ctx.db
      .query("users")
      .withIndex("by_workos_id", (q) => q.eq("workosUserId", args.workosUserId))
      .unique();

    if (existing) {
      await ctx.db.patch(existing._id, {
        email: args.email,
        displayName: args.name,
        updatedAt: Date.now(),
      });
      return existing._id;
    } else {
      return await ctx.db.insert("users", {
        workosUserId: args.workosUserId,
        email: args.email,
        displayName: args.name,
        isActive: true,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    }
  },
});
```

### 2. Soft Delete Pattern

```typescript
export const deleteMeeting = mutation({
  args: { meetingId: v.id("meetings") },
  returns: v.null(),
  handler: async (ctx, args) => {
    await assertMeetingAccess(ctx, args.meetingId, "host");

    // Soft delete by updating state
    await ctx.db.patch(args.meetingId, {
      state: "cancelled" as const,
      updatedAt: Date.now(),
    });

    return null;
  },
});
```

### 3. Audit Logging Pattern

```typescript
async function logAuditEvent(
  ctx: any,
  action: string,
  resourceType: string,
  resourceId: string,
  metadata?: any,
) {
  const { userId } = requireIdentity(ctx);

  await ctx.db.insert("auditLogs", {
    actorUserId: userId,
    resourceType,
    resourceId,
    action,
    metadata: metadata || {},
    timestamp: Date.now(),
  });
}

export const updateMeeting = mutation({
  args: {
    meetingId: v.id("meetings"),
    title: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    await assertMeetingAccess(ctx, args.meetingId, "host");

    const oldMeeting = await ctx.db.get(args.meetingId);

    await ctx.db.patch(args.meetingId, {
      title: args.title,
      updatedAt: Date.now(),
    });

    // Log the change
    await logAuditEvent(ctx, "update", "meeting", args.meetingId, {
      oldTitle: oldMeeting?.title,
      newTitle: args.title,
    });

    return null;
  },
});
```

## Best Practices

### 1. Security

- Always validate authentication
- Use least privilege access control
- Log sensitive operations
- Validate all inputs

### 2. Performance

- Use appropriate indexes
- Implement pagination
- Batch related operations
- Monitor query performance

### 3. Maintainability

- Use consistent naming conventions
- Document complex logic
- Write comprehensive tests
- Follow TypeScript best practices

### 4. Error Handling

- Provide meaningful error messages
- Use consistent error patterns
- Log errors with context
- Handle edge cases gracefully

## Resources

- [Convex Documentation](https://docs.convex.dev)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [Project Specifications](./.kiro/specs/convex-database-migration/)
- [Deployment Guide](./DEPLOYMENT.md)


Onboarding Flow (WorkOS + Convex)

- Client auth via WorkOS AuthKit → Convex. User is upserted on auth by `UpsertUserOnAuth` in `src/providers/ConvexClientProvider.tsx` calling `api.users.mutations.upsertUser`.
- Single atomic save: `api.users.mutations.saveOnboarding` persists:
  - Profile: `age, gender, field, jobTitle, company, linkedinUrl, bio`
  - Interests: validated canonical keys; allows controlled custom (category `personal`) seeded into catalog as `custom:<slug>`
  - User flags: `onboardingComplete`, `onboardingCompletedAt`
  - Idempotent: uses `idempotencyKeys` under scope `users.onboarding.saveOnboarding`
  - Audited: `auditLogs` entry `onboarding.save`

Schema

- `users`: adds `onboardingComplete`, `onboardingStartedAt`, `onboardingCompletedAt`; index `by_onboarding_complete`.
- `profiles`: contains all structured onboarding fields for long-term use and indexing.
- `interests` + `userInterests`: canonical catalog and user selections.

Queries

- `api.users.queries.getOnboardingState` → `{ userId, onboardingComplete, profileExists, profileId?, completedAt? }` used to route users.
- `api.interests.queries.listCatalog` → preload interests (key, label, category, usageCount?).

Frontend

- `src/app/onboarding/page.tsx`: uses `saveOnboarding` mutation; computes idempotency key from form values; redirects to `/app` on success or if `getOnboardingState.onboardingComplete` is true.
- `src/components/onboarding/InterestsSection.tsx`: loads catalog via `useQuery(api.interests.queries.listCatalog)` and allows selectable + custom interests.

Testing

- `convex/users/onboarding.test.ts`: happy path, invalid interest, idempotency. Seeds catalog directly via `t.run` inserts for isolation.

Notes

- Always use new Convex function syntax with explicit validators and return validators.
- Avoid table scans; all lookups use indexes: `interests.by_key`, `profiles.by_user`, `userInterests.by_user`, `users.by_workos_id`.
- Keep types consistent; no `any` in public interfaces. Use runtime guards when narrowing unknown metadata.
