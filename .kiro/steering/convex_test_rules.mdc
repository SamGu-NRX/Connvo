================
CODE SNIPPETS
================
TITLE: Test Convex Functions with convex-test and Vitest
DESCRIPTION: Utilize the `convex-test` library to write and execute automated tests for your Convex functions directly in JavaScript, leveraging the Vitest testing framework for a robust testing experience. This method allows for isolated testing of function logic without needing a full backend deployment.

SOURCE: https://docs.convex.dev/testing

LANGUAGE: javascript
CODE:
```
import { ConvexTester } from 'convex-test';

// Assuming you have a function named 'myFunction' in your Convex project
const tester = new ConvexTester();

test('myFunction should return correct value', async () => {
  const result = await tester.run('myFunction', { arg1: 'value1' });
  expect(result).toBe('expectedValue');
});

test('myFunction should handle errors', async () => {
  await expect(tester.run('myFunction', { invalidArg: true })).rejects.toThrow();
});

```

--------------------------------

TITLE: Testing Convex Queries, Mutations, and Actions
DESCRIPTION: Learn how to test Convex functions using `t.query`, `t.mutation`, and `t.action`. This section covers the basic setup and execution of tests for different types of Convex functions.

SOURCE: https://docs.convex.dev/testing/convex-test

LANGUAGE: javascript
CODE:
```
import { expect } from "chai";
import { t } from "convex-test";

describe("myFunctions", () => {
  it("should test a query", async () => {
    const result = await t.query("myQuery", {});
    expect(result).to.equal("expected result");
  });

  it("should test a mutation", async () => {
    await t.mutation("myMutation", { arg1: "value1" });
    // Assert state changes if necessary
  });

  it("should test an action", async () => {
    const result = await t.action("myAction", { arg1: "value1" });
    expect(result).to.equal("expected action result");
  });
});
```

LANGUAGE: typescript
CODE:
```
import { expect } from "chai";
import { t } from "convex-test";
import { Doc } from "./convex/_generated/dataModel";

describe("myFunctions", () => {
  it("should test a query", async () => {
    const result = await t.query("myQuery", {});
    expect(result).to.equal("expected result");
  });

  it("should test a mutation", async () => {
    await t.mutation("myMutation", { arg1: "value1" });
    // Assert state changes if necessary
  });

  it("should test an action", async () => {
    const result = await t.action("myAction", { arg1: "value1" });
    expect(result).to.equal("expected action result");
  });
});
```

--------------------------------

TITLE: Testing Authentication with `t.withIdentity`
DESCRIPTION: Learn how to test Convex functions that rely on user authentication using `t.withIdentity`. This allows you to simulate different user identities during testing.

SOURCE: https://docs.convex.dev/testing/convex-test

LANGUAGE: javascript
CODE:
```
import { expect } from "chai";
import { t } from "convex-test";

describe("authProtectedActions", () => {
  it("should test an action with a specific user identity", async () => {
    const user = {
      _id: "user123",
      tokenIdentifier: "token123",
    };
    const result = await t.withIdentity(user).action("getUserData", {});
    expect(result).to.equal("user data for user123");
  });
});
```

--------------------------------

TITLE: Example Test for Sending and Listing Messages
DESCRIPTION: Demonstrates how to write a test case using `convex-test` and Vitest. It mocks a Convex backend, calls a mutation to send messages, and then queries for the messages to assert the expected results.

SOURCE: https://docs.convex.dev/testing/convex-test

LANGUAGE: typescript
CODE:
```
import{ convexTest }from"convex-test";
import{ expect, test }from"vitest";
import{ api }from"./_generated/api";
import schema from"./schema";

test("sending messages",async()=>{
const t =convexTest(schema);
await t.mutation(api.messages.send,{ body:"Hi!", author:"Sarah"});
await t.mutation(api.messages.send,{ body:"Hey!", author:"Tom"});
const messages =await t.query(api.messages.list);
expect(messages).toMatchObject([
{ body:"Hi!", author:"Sarah"},
{ body:"Hey!", author:"Tom"}
]);
});

```

--------------------------------

TITLE: Install convex-test and Vitest Dependencies
DESCRIPTION: Installs the necessary testing libraries, including `convex-test`, `vitest`, and `@edge-runtime/vm`, as development dependencies for your project.

SOURCE: https://docs.convex.dev/testing/convex-test

LANGUAGE: bash
CODE:
```
npm install --save-dev convex-test vitest @edge-runtime/vm

```

--------------------------------

TITLE: Call Convex Functions (Query, Mutation, Action)
DESCRIPTION: Illustrates how to use the `t` object returned by `convexTest` to call various types of Convex functions, including public and internal queries, mutations, and actions, with their respective arguments.

SOURCE: https://docs.convex.dev/testing/convex-test

LANGUAGE: typescript
CODE:
```
import{ convexTest }from"convex-test";
import{ test }from"vitest";
import{ api, internal }from"./_generated/api";

test("functions",async()=>{
const t =convexTest();
const x =await t.query(api.myFunctions.myQuery,{ a:1, b:2});
const y =await t.query(internal.myFunctions.internalQuery,{ a:1, b:2});
const z =await t.mutation(api.myFunctions.mutateSomething,{ a:1, b:2});
const w =await t.mutation(internal.myFunctions.mutateSomething,{ a:1});
const u =await t.action(api.myFunctions.doSomething,{ a:1, b:2});
const v =await t.action(internal.myFunctions.internalAction,{ a:1, b:2});
});

```

--------------------------------

TITLE: Test Convex Functions with Local Backend (JS)
DESCRIPTION: This guide explains how to test Convex functions using the local backend, which offers advantages like running against production code and enforcing limits. It also outlines limitations such as setup complexity and the inability to mock `fetch` or dependencies.

SOURCE: https://docs.convex.dev/testing/convex-backend

LANGUAGE: JavaScript
CODE:
```
To test your functions in JS with a mocked Convex backend, check out convex-test.
```

--------------------------------

TITLE: Asserting Errors in Convex Functions with Vitest
DESCRIPTION: Shows how to assert that a Convex function throws a specific error using Vitest's `.rejects.toThrowError()` matcher. This is crucial for validating error handling logic in your mutations or actions. The example tests a mutation that should reject due to an empty message body.

SOURCE: https://docs.convex.dev/testing/convex-test

LANGUAGE: TS
CODE:
```
import{ convexTest }from"convex-test";
import{ expect, test }from"vitest";
import{ api }from"./_generated/api";
import schema from"./schema";

test("messages validation",async()=>{
const t =convexTest(schema);
expect(async()=>{
await t.mutation(api.messages.send,{ body:"", author:"James"});
}).rejects.toThrowError("Empty message body is not allowed");
});
```

--------------------------------

TITLE: Handling Custom Convex Folder Locations with Vitest
DESCRIPTION: Explains how to configure Vitest to find Convex functions when the `convex/` folder has a custom name or location. It involves using `import.meta.glob` to specify the pattern for Convex function files and passing the result to `convexTest`.

SOURCE: https://docs.convex.dev/testing/convex-test

LANGUAGE: TS
CODE:
```
/// <reference types="vite/client" />
exportconst modules =import.meta.glob("./**/!(*.*.*)*.*s");
```

LANGUAGE: TS
CODE:
```
import{ convexTest }from"convex-test";
import{ test }from"vitest";
import schema from"./schema";
import{ modules }from"./test.setup";

test("some behavior",async()=>{
const t =convexTest(schema, modules);
// use `t`...
```

--------------------------------

TITLE: Configure Vitest for Convex Runtime
DESCRIPTION: Sets up the Vitest configuration file (`vitest.config.mts`) to use the 'edge-runtime' environment and inline `convex-test` dependencies for accurate testing of Convex functions.

SOURCE: https://docs.convex.dev/testing/convex-test

LANGUAGE: typescript
CODE:
```
import{ defineConfig }from"vitest/config";

exportdefault defineConfig({
  test:{
    environment:"edge-runtime",
    server:{ deps:{ inline:["convex-test"]}},

```

--------------------------------

TITLE: Initialize convexTest with Schema
DESCRIPTION: Shows how to initialize the `convexTest` function by passing your project's schema. This is crucial for schema validation and type safety when interacting with Convex functions in your tests.

SOURCE: https://docs.convex.dev/testing/convex-test

LANGUAGE: typescript
CODE:
```
import{ convexTest }from"convex-test";
import{ test }from"vitest";
import schema from"./schema";

test("some behavior",async()=>{
const t =convexTest(schema);
// use `t`...
});

```

--------------------------------

TITLE: Test Scheduled Functions with Fake Timers
DESCRIPTION: Leverage Vitest's fake timers with `t.finishInProgressScheduledFunctions` to test functions that rely on scheduled mutations or actions. This allows precise control over time progression for testing delayed operations.

SOURCE: https://docs.convex.dev/testing/convex-test

LANGUAGE: typescript
CODE:
```
import{ convexTest }from"convex-test";
import{ expect, test, vi }from"vitest";
import{ api }from"./_generated/api";
import schema from"./schema";

test("mutation scheduling action",async()=>{
// Enable fake timers
  vi.useFakeTimers();

const t =convexTest(schema);

// Call a function that schedules a mutation or action
const scheduledFunctionId =await t.mutation(
    api.scheduler.mutationSchedulingAction,
{ delayMs:10000},
);

// Advance the mocked time
  vi.advanceTimersByTime(5000);

// Advance the mocked time past the scheduled time of the function
  vi.advanceTimersByTime(6000);

// Or run all currently pending timers
  vi.runAllTimers();

// At this point the scheduled function will be `inProgress`,
// now wait for it to finish
await t.finishInProgressScheduledFunctions();

// Assert that the scheduled function succeeded or failed
const scheduledFunctionStatus = t.run(async(ctx)=>{
returnawait ctx.db.get(scheduledFunctionId);
});
expect(scheduledFunctionStatus).toMatchObject({ state:{ kind:"success"}});

// Reset to normal `setTimeout` etc. implementation
  vi.useRealTimers();
});


```

--------------------------------

TITLE: Test Chained Scheduled Functions with t.finishAllScheduledFunctions
DESCRIPTION: For sequences of scheduled functions, including recursive ones, `t.finishAllScheduledFunctions` can be used to ensure all operations complete. This involves repeatedly advancing time and waiting for in-progress functions to finish.

SOURCE: https://docs.convex.dev/testing/convex-test

LANGUAGE: typescript
CODE:
```
import{ convexTest }from"convex-test";
import{ expect, test, vi }from"vitest";
import{ api }from"./_generated/api";
import schema from"./schema";

test("mutation scheduling action scheduling action",async()=>{
// Enable fake timers
  vi.useFakeTimers();

const t =convexTest(schema);

// Call a function that schedules a mutation or action
await t.mutation(api.scheduler.mutationSchedulingActionSchedulingAction);

// Wait for all scheduled functions, repeatedly
// advancing time and waiting for currently in-progress
// functions to finish
await t.finishAllScheduledFunctions(vi.runAllTimers);

// Assert the resulting state after all scheduled functions finished
const createdTask = t.run(async(ctx)=>{
returnawait ctx.db.query("tasks").first();
});
expect(createdTask).toMatchObject({ author:"AI"});

// Reset to normal `setTimeout` etc. implementation
  vi.useRealTimers();
});


```

--------------------------------

TITLE: Test Authentication with t.withIdentity
DESCRIPTION: Simulate authenticated users in tests using `t.withIdentity`, which allows specifying user identity attributes like `name`. If attributes are omitted, `issuer`, `subject`, and `tokenIdentifier` are auto-generated.

SOURCE: https://docs.convex.dev/testing/convex-test

LANGUAGE: typescript
CODE:
```
import{ convexTest }from"convex-test";
import{ expect, test }from"vitest";
import{ api }from"./_generated/api";
import schema from"./schema";

test("authenticated functions",async()=>{
const t =convexTest(schema);

const asSarah = t.withIdentity({ name:"Sarah"});
await asSarah.mutation(api.tasks.create,{ text:"Add tests"});

const sarahsTasks =await asSarah.query(api.tasks.list);
expect(sarahsTasks).toMatchObject([{ text:"Add tests"}]);

const asLee = t.withIdentity({ name:"Lee"});
const leesTasks =await asLee.query(api.tasks.list);
expect(leesTasks).toEqual([]);
});


```

--------------------------------

TITLE: Configuring Vitest Environments with environmentMatchGlobs
DESCRIPTION: Illustrates how to configure Vitest to use different environments based on file paths using `environmentMatchGlobs`. This is useful when testing components that require specific runtimes, such as the edge-runtime for Convex functions and jsdom for frontend code.

SOURCE: https://docs.convex.dev/testing/convex-test

LANGUAGE: TS
CODE:
```
import{ defineConfig }from"vitest/config";

exportdefault defineConfig({
  test:{
    environmentMatchGlobs:[
// all tests in convex/ will run in edge-runtime
["convex/**","edge-runtime"],
// all other tests use jsdom
["**","jsdom"],
],
    server:{ deps:{ inline:["convex-test"]}},
},
});
```

--------------------------------

TITLE: Run Convex Functions from Command Line
DESCRIPTION: Manually execute Convex functions directly from your command line interface during development. This is a quick way to test specific function behavior and inspect its output without needing to trigger it through the application's UI.

SOURCE: https://docs.convex.dev/testing

LANGUAGE: bash
CODE:
```
npx convex dev --exec myFunctionName --args '{"name": "test"}'

```

--------------------------------

TITLE: Mocking fetch Calls with Vitest
DESCRIPTION: Demonstrates how to mock global fetch calls within a Vitest test environment. This is useful for isolating Convex functions and testing their behavior without making actual network requests. It uses `vi.stubGlobal` to replace the native fetch with a mock function.

SOURCE: https://docs.convex.dev/testing/convex-test

LANGUAGE: TS
CODE:
```
import{ expect, test, vi }from"vitest";
import{ convexTest }from"../index";
import{ api }from"./_generated/api";
import schema from"./schema";

test("ai",async()=>{
const t =convexTest(schema);

  vi.stubGlobal(
"fetch",
    vi.fn(async()=>({text:async()=>"I am the overlord"})as Response),
);

const reply =await t.action(api.messages.sendAIMessage,{ prompt:"hello"});
expect(reply).toEqual("I am the overlord");

  vi.unstubAllGlobals();
});
```

--------------------------------

TITLE: Testing HTTP Actions with `t.fetch`
DESCRIPTION: This section details how to test HTTP actions within Convex by mocking `fetch` calls using `t.fetch`. It allows you to simulate external API responses for your tests.

SOURCE: https://docs.convex.dev/testing/convex-test

LANGUAGE: javascript
CODE:
```
import { expect } from "chai";
import { t } from "convex-test";

describe("httpActions", () => {
  it("should test an HTTP action", async () => {
    t.fetch.mockResolvedValueOnce({
      ok: true,
      json: async () => ({ data: "mocked data" }),
    });

    const result = await t.action("fetchDataAction", {});
    expect(result).to.deep.equal({ data: "mocked data" });
  });
});
```

--------------------------------

TITLE: Run Data Operations in Tests with t.run
DESCRIPTION: The `t.run` method allows direct interaction with the mock database and file storage within tests. It takes a handler that receives a `ctx` object for reading and writing data.

SOURCE: https://docs.convex.dev/testing/convex-test

LANGUAGE: typescript
CODE:
```
import{ convexTest }from"convex-test";
import{ expect, test }from"vitest";

test("functions",async()=>{
const t =convexTest();
const firstTask =await t.run(async(ctx)=>{
await ctx.db.insert("tasks",{ text:"Eat breakfast"});
returnawait ctx.db.query("tasks").first();
});
expect(firstTask).toMatchObject({ text:"Eat breakfast"});
});


```
